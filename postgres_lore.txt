--> Show table permissions:
SELECT *
  FROM information_schema.role_table_grants
 WHERE grantee = 'YOUR_USER';

-- NOTE: permissions gained from roles granted to 'YOUR_USER' won't show up here.

--> Show table ownership:
SELECT *
  FROM pg_tables
 WHERE tableowner = 'YOUR_USER';

--> Show schema permissions (Note: if a user owns a table or database, no special grant exists as the owner of an object always has full access to that object (without grants). Note: if a user only has USAGE access to the schema nothing will be displayed here.
SELECT r.usename AS grantor,
             e.usename AS grantee,
             nspname,
             privilege_type,
             is_grantable
        FROM pg_namespace
JOIN LATERAL (SELECT *
                FROM aclexplode(nspacl) AS x) a
          ON true
        JOIN pg_user e
          ON a.grantee = e.usesysid
        JOIN pg_user r
          ON a.grantor = r.usesysid
       WHERE e.usename = 'YOUR_USER';

--> https://neon.tech/postgresql/postgresql-tutorial/postgresql-fetch
Some interesting info that could be useful for pagination over stable result sets.

--> https://neon.tech/postgresql/postgresql-tutorial/postgresql-merge
The merge feature handles inserts/updates/deletes in a single statement and the RETURNING clause provides information on which of the operations it performed.

--> https://dev.to/dwd/efficient-insert-multiple-with-postgres-3f06
Relevant to the hand rolled persistence we do in our runtime...
To chain related inserts together (e.g. resolving foreign key relationships) in a single network call:

WITH step_one AS (
  INSERT INTO foo(blah, wibble)
  VALUES($1, $2)
  RETURNING id
),
WITH step_two AS (
  INSERT INTO bar(blook)
  VALUES($3)
  RETURNING id
),
INSERT INTO other(foo_id, floogle, bar_id) SELECT s1.id, $4, s2.id FROM step_one s1, step_two s2

or, more elaborately:

WITH my_data(blah, wibble, blook, floogle) AS (
  VALUES ($1, $2,$3, $4::BIGINT)
),
WITH step_one AS (
  INSERT INTO foo(blah, wibble)
  SELECT m.blah, m.wibble FROM my_data m
  RETURNING id
),
WITH step_two AS (
  INSERT INTO bar(blook)
  SELECT m.blook FROM my_data m
  RETURNING id
),
INSERT INTO other(foo_id, floogle, bar_id)
SELECT s1.id, m.floogle, s2.id
FROM step_one s1, step_two s2, my_data m

Clever :-)


-- Creating temp tables as a clone of an existing table:
CREATE TEMP TABLE temp_users (LIKE users); --> creates a temp table with the same schema as the table referenced by the LIKE clause.
-- NOTE: Remove the TEMP and the same creates a permanent table


-- I needed to bone up on SQL window functions and thought it would be good to put a note here
-- She asked the following question with given sample data.
-- Write a SQL query to return the count of users who has the status 'Registered' as of end of day 2025-01-08

CREATE TABLE status_change_log
(
    user_id INT,
    updated_at TIMESTAMP,
    status VARCHAR(50)
);

INSERT INTO status_change_log
    ( userid,  updated_at,            status)
VALUES
    ( 1234567, '2025-01-01 04:00:00', 'Enrolled'  ),
    ( 1234567, '2025-01-08 13:00:00', 'Registered'),
    ( 1234567, '2025-01-08 14:00:00', 'Canceled'  ),
    ( 1234567, '2025-01-09 13:00:00', 'Registered'),
    ( 1234567, '2025-01-15 18:00:00', 'Completed' ),
    ( 8675309, '2025-01-03 04:00:00', 'Enrolled'  ),
    ( 8675309, '2025-01-03 05:00:00', 'Canceled'  ),
    ( 8675309, '2025-01-03 06:00:00', 'Enrolled'  ),
    ( 8675309, '2025-01-05 08:00:00', 'Registered'),
    ( 8675309, '2025-01-20 18:00:00', 'Completed' ),
    ( 9876543, '2025-01-04 04:00:00', 'Registered'),
    ( 9876543, '2025-01-14 10:00:00', 'Paused'    ),
    ( 9876543, '2025-01-17 10:00:00', 'Registered'),
    ( 9876543, '2025-01-18 22:00:00', 'Complete'  ),
    ( 1001001, '2025-01-04 04:00:00', 'Enrolled'  ),
    ( 1001001, '2025-01-18 04:00:00', 'Registered')
;

SELECT count(*) FROM (
    SELECT
        user_id, updated_at, first_value(status)
    OVER
        (PARTITION by user_id ORDER BY updated_at DESC)
    FROM
        status_change_log
    WHERE
        status = 'Registered'
        AND
        updated_at < '2025-01-09'
);

Without the outer count, the results look like this:

     user_id |      updated_at     | first_value
    ---------+---------------------+-------------
     1234567 | 2025-01-08 13:00:00 | Registered
     8675309 | 2025-01-05 08:00:00 | Registered
     9876543 | 2025-01-04 04:00:00 | Registered

